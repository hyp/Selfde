//
//  machControllerImpl.c
//  Selfde
//

#include "machControllerImpl.h"
#include <sys/types.h>
#include <sys/ptrace.h>
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>

// Context that's passed into the exception handler thread.
// It is valid until the semaphore is signalled.
typedef struct ExceptionHandlerContext {
    dispatch_semaphore_t semaphore;
    SelfdeMachControllerState *state;
} ExceptionHandlerContext;

// Global state only accessed by the exception handler thread.
typedef struct ExceptionHandlerGlobalState {
    mach_port_t thread;
    exception_type_t exception;
    exception_data_t codeVector;
    mach_msg_type_number_t codeCount;
    bool isValid;
} ExceptionHandlerGlobalState;

// Should only be accessed by the exception handler thread.
static ExceptionHandlerGlobalState *gExceptionState = NULL;
static pthread_mutex_t gExceptionMutex;
static dispatch_semaphore_t gExceptionSemaphore;

kern_return_t catch_exception_raise(mach_port_t exception_port, mach_port_t thread, mach_port_t task, exception_type_t exception, exception_data_t codeVector, mach_msg_type_number_t codeCount) {
    printf("catch_exception_raise - me: %d, victim: %d, exception type: %d\n", mach_thread_self(), thread, exception);

    // Suspend the thread with the exception.
    thread_suspend(thread);

    // Save the information.
    pthread_mutex_lock(&gExceptionMutex);
    gExceptionState->thread = thread;
    gExceptionState->exception = exception;
    gExceptionState->codeVector = codeVector;
    gExceptionState->codeCount = codeCount;
    if (gExceptionState->isValid) {
        printf("Warning: catch_exception_raise: the controller has missed an exception!\n");
    }
    gExceptionState->isValid = true;
    pthread_mutex_unlock(&gExceptionMutex);
    dispatch_semaphore_signal(gExceptionSemaphore);

    return KERN_SUCCESS;
}

// Autogenerated somewhere in the system Libs..
extern boolean_t exc_server(mach_msg_header_t *msg, mach_msg_header_t *reply);

static void *exceptionHandlerThreadMain(void *arg) {
#if defined (__APPLE__)
    pthread_setname_np("exception monitoring thread");
#endif
    // Get the port and set the message server thread in the state.
    ExceptionHandlerContext *context = (ExceptionHandlerContext *)arg;
    mach_port_t port = context->state->exceptionPort;
    context->state->msgServerThread = mach_thread_self();

    // Resume the controller thread and invalidate the context..
    printf("Exception thread main\n");
    dispatch_semaphore_signal(context->semaphore);
    context = NULL;

    // Run the server.
    gExceptionState = malloc(sizeof(ExceptionHandlerGlobalState));
    gExceptionState->isValid = false;
    mach_msg_server(exc_server, 2048, port, 0);
    abort();
}

int selfdeInitMachController(SelfdeMachControllerState *state) {
    // TODO: check
    state->task = mach_task_self();
    state->controllerThread = mach_thread_self();
    state->msgServerThread = state->controllerThread;
    
    // Init sync mutex.
    pthread_mutex_init(&gExceptionMutex, NULL);
    gExceptionSemaphore = dispatch_semaphore_create(0);

    // Create exception port.
    mach_error_t ret = mach_port_allocate(state->task, MACH_PORT_RIGHT_RECEIVE, &(state->exceptionPort));
    if (ret != KERN_SUCCESS) {
        return ret;
    }
    mach_port_t exceptionPort = state->exceptionPort;
    ret = mach_port_insert_right(state->task, exceptionPort, exceptionPort, MACH_MSG_TYPE_MAKE_SEND);
    if (ret != KERN_SUCCESS) {
        return ret;
    }

    // Apply the exception port to all user threads.
    thread_act_port_array_t threads;
    mach_msg_type_number_t count = 0;
    ret = task_threads(state->task, &threads, &count);
    if (ret != KERN_SUCCESS) {
        return ret;
    }
    for (mach_msg_type_number_t i = 0; i < count; ++i) {
        mach_port_t thread = threads[i];
        if (thread == state->controllerThread) { continue; }
        ret = thread_set_exception_ports(thread, EXC_MASK_BREAKPOINT, exceptionPort, EXCEPTION_DEFAULT, THREAD_STATE_NONE);
        if (ret != KERN_SUCCESS) {
            return ret;
        }
    }

    // Start the msg server thread.
    pthread_t exceptionHadlerThread;
    ExceptionHandlerContext context;
    context.semaphore = dispatch_semaphore_create(0);
    context.state = state;
    if (ret != 0) {
        return ret;
    }
    ret = pthread_create(&exceptionHadlerThread, NULL, exceptionHandlerThreadMain, &context);
    if (ret != 0) {
        return ret;
    }
    printf("Waiting for the exception thread to initialize..\n");
    dispatch_semaphore_wait(context.semaphore, DISPATCH_TIME_FOREVER);
    dispatch_release(context.semaphore);
    printf("Initialized controller thread! Controller thread: %d, message server thread: %d\n", state->controllerThread, state->msgServerThread);
    return KERN_SUCCESS;
}

int selfdeWaitForException(SelfdeMachControllerState *state, SelfdeMachException *exception) {
    while (true) {
        dispatch_semaphore_wait(gExceptionSemaphore, DISPATCH_TIME_FOREVER);
        pthread_mutex_lock(&gExceptionMutex);
        bool consumed = gExceptionState->isValid;
        if (consumed) {
            exception->thread = gExceptionState->thread;
            exception->exception = gExceptionState->exception;
        }
        gExceptionState->isValid = false;
        pthread_mutex_unlock(&gExceptionMutex);
        if (consumed) {
            break;
        }
    }
    return 0;
}

vm_prot_t getVMProtAll() {
    return VM_PROT_ALL;
}

vm_prot_t getVMProtRead() {
    return VM_PROT_READ;
}

vm_prot_t getVMProtWrite() {
    return VM_PROT_WRITE;
}

vm_prot_t getVMProtExecute() {
    return VM_PROT_EXECUTE;
}
